NOTES FOR RAYTRACING SOFTWARE

** References

scratchapixel.com
	note that the "old website" has more complete discussion of some of the more
	advanced topics

http://www.flipcode.com/archives/Raytracing_Topics_Techniques-Part_5_Soft_Shadows.shtml
http://www.thepolygoners.com/tutorials/GIIntro/GIIntro.htm -- this may be defunct

PBRT book


http://www.flipcode.com/archives/Raytracing_Topics_Techniques-Part_1_Introduction.shtml


http://web.cs.wpi.edu/~emmanuel/courses/cs563/write_ups/zackw/realistic_raytracing.html



imagemagick or graphicsmagick ("gm") for image conversion


* Sampling from cosine distribution (for diffuse reflection):
https://www.particleincell.com/2015/cosine-distribution/
[with Python code]


** NOTES ON "COLOR" CLASS:

Color is a 3-element array essentially identical to Vec3f (with internal components
labeled r,g,b instead of x,y,z and with some unnecessary functions like dot products
not defined, so it's not a true geometric vector).

Colors can be additive: c1 + c2

But Colors can also be used as multiplicative scaling factors. E.g., to represent
wavelength-dependent albedo, we can have
	Color albedo = Color(0.5, 0.8, 0.9)
And thus we can compute the effect of albedo on an incoming light beam
as L_out = L_in * albedo = (L_in.r * albedo.r, L_in.g * albedo.g, L_in.b * albedo.b)



** ILLUMINATION NOTES:

Lambert's Law: Light arriving at a surface is attenuated due to angle
(think attenuation of sunlight on surface of earth at high latitudes):
	L_at-surface = L_in cos(alpha)
		where alpha = angle between incident light ray and normal to surface
	L_at-surface = L_in * (omega_in dot normal)
		where omega_in = direction vector for incident light and
		normal = normal vector of surface



Diffuse reflection: light is reflected uniformly into outgoing hemisphere


** SHADING NOTES:

Problem is that with simple geometry (including triangles in a mesh), the
normal for a surface may not be accurate
	NOT a problem for spheres and planes -- we can easily compute correct
	normal at a point
	IS a problem for e.g. triangle meshes approximating a smooth surface:
	How do you compute the normal for a given intersection point?

Flat shading: same normal for entire triangle -- simple, fast, not good

Gouraud shading: -- better, slower, still not very good

Phong Shading (different from Phong Illumination model) -- slower, best
	linear interpolation of surrounding normals

Blinn-Phong: improvement on Phong, with better handling of high-angle
	specular reflection. About the same computational expense.



** Skybox cubemap images

http://www.humus.name/index.php?page=Textures
	2048x2048 JPEG -- lots of photos of urban and rural/park spaces

http://www.custommapmakers.org/skyboxes.php
	512x512 TGA -- mostly Bryce-style landcalse

https://pypi.org/project/sphere2cube/
"a script to map equirectangular (cylindrical projection, skysphere) map
into 6 cube (cubemap, skybox) faces." [requires Blender be installed]

https://matheowis.github.io/HDRI-to-CubeMap/
	online converter of HDRI spherical maps to cube maps




** OBJ files:
* Self-contained header-only code for loading OBJ files:
https://github.com/syoyo/tinyobjloader
	includes some simple .obj and .mtl files (including Cornell box)

https://en.wikipedia.org/wiki/Wavefront_.obj_file
http://www.fileformat.info/format/material/ -- note that officially there
are fancier options where you can specify colors in XYZ or even refer
to a file with a spectrum...
